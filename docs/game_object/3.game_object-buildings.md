# Cookie Clicker Building Data Structure

## 1. Introduction

This document details the data structure for the "buildings" field as serialized in the `main.js` save file. It compares the original JavaScript implementation with the Python parser to identify the root cause of discrepancies during the decode-parse-serialize-encode cycle.

## 2. JavaScript Serialization (`main.js`)

The game serializes the data for each building into a single string, with 7 distinct fields separated by commas. The logic can be summarized by this JavaScript snippet from the `Game.WriteSave` function:

```javascript
// For each building 'me':
var str = me.amount + ',' + me.bought + ',' + me.totalCookies + ',' + me.level + ',' + (me.minigame ? me.minigame.save() : (me.minigameSave || 0)) + ',' + me.muted + ',' + (me.highest || me.amount);
```

### Field-by-Field Breakdown

Here are the 7 fields in the order they appear:

1.  **`amount`**: (Integer) The current number of this building the player owns.
2.  **`bought`**: (Integer) The total number of this building the player has ever purchased.
3.  **`totalCookies`**: (Float) The total number of cookies this specific building has produced throughout its lifetime.
4.  **`level`**: (Integer) The building's sugar lump level. Defaults to `0` if not present.
5.  **`minigame_save`**: (String|Integer) The save data for the building's associated minigame (e.g., Grimoire, Pantheon). This is generated by a specific `save()` function for the minigame. If no minigame exists or its save data is empty, this defaults to `0`.
6.  **`muted`**: (Integer) A boolean flag (`1` for true, `0` for false) indicating if the building's ambient sound is muted.
7.  **`highest`**: (Integer) The highest number of this building the player has ever owned simultaneously. **This field has special conditional logic.**

## 3. Building Order and Index

The game serializes the building data by iterating through the `Game.ObjectsById` array in the exact order the buildings were initialized. This order is fixed. The following table lists all buildings by their in-game name and their corresponding index (position) in the save file's building data string.

| Index | Building Name |
|---|---|
| 0 | Cursor |
| 1 | Grandma |
| 2 | Farm |
| 3 | Mine |
| 4 | Factory |
| 5 | Bank |
| 6 | Temple |
| 7 | Wizard tower |
| 8 | Shipment |
| 9 | Alchemy lab |
| 10 | Portal |
| 11 | Time machine |
| 12 | Antimatter condenser |
| 13 | Prism |
| 14 | Chancemaker |
| 15 | Fractal engine |
| 16 | Javascript console |
| 17 | Idleverse |
| 18 | Cortex baker |
| 19 | You |

# Previous Version

## 3. Analysis of Discrepancy

  The Python parser and serializer correctly handle the first 6 fields. The
  mismatch originates entirely from the logic of the 7th field,  highest .

  • JavaScript Logic:  (me.highest || me.amount)
    • This expression means that if the  me.highest  property is present and
    not a "falsy" value (like 0 or null), its value is used.
    • However, if  me.highest  is falsy, the game uses the value of  me.amount
    in its place during serialization. This is a form of data compression; if
    the highest amount ever owned is the same as the current amount, there's
    no need to store it separately.
  • Python Parser Logic:  'highest': int(parts[6] or 0)
    • The Python parser correctly takes the 7th element from the split string.
    • If that element is empty, it correctly defaults the value to  0 .
  • The Core Flaw: The Python parser lacks the context of the JavaScript
  code's conditional logic. When it encounters a save where the  highest
  value was omitted (because it was the same as  amount ), the parser
  correctly interprets the empty field as  0 . However, it does not know that
  it should have been the  amount . When this data is later re-serialized, the
  Python script writes  0  for the  highest  field, while the original save
  string implicitly contained the  amount , leading to a mismatch.

  ### Example Scenario

  • A player has 100 Cursors and has never sold any.
  • In  main.js ,  me.amount  is 100 and  me.highest  might be 0 or undefined.
  • The JavaScript serializer executes  (0 || 100) , resulting in  100  being
  written to the save string for the  highest  field.
  • If a different save is loaded where  highest  was explicitly saved as  120 ,
  that value would be used.
  • The Python parser does not replicate this  || me.amount  fallback, causing
  the discrepancy.