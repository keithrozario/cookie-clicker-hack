# Cookie Clicker: Data Encoding and File Generation

## 1. Introduction

This document provides a comprehensive analysis of the final stage of the game export process: data encoding and file generation. This stage occurs after the entire game state has been serialized into a single string. The primary goal is to convert this string into a portable, robust format that the user can easily save to a file.

It is critical to understand that the encoding process does not act on individual game variables one by one. Instead, it acts on a **single, monolithic string variable**, referred to as `str` in the `Game.WriteSave` function. This `str` variable contains the complete, serialized game state, as detailed in the `data_serialization.md` document.

## 2. The Source: The Serialized Game State String (`str`)

Before encoding begins, the `Game.WriteSave` function has aggregated every piece of save data into one variable, `str`. This variable is the sole input for the encoding process. It is a long string of text containing all player progress, including:

-   Version and timestamp information
-   Player preferences (as a bitfield)
-   Core stats (cookies, clicks, prestige, etc.)
-   Building, upgrade, and achievement data (in compressed formats)
-   Minigame states
-   Mod data

All these individual data points are concatenated together using `|` and `;` delimiters to form the `str` variable.

## 3. Base64 Encoding: The `utf8_to_b64` function

The primary step in encoding is to convert the `str` variable into Base64. This is done to ensure the data can be safely copied, pasted, and stored in a text file without being corrupted by character set issues or special characters. The game uses a custom function, `utf8_to_b64`, to accomplish this, as the standard browser `btoa()` function can fail on non-ASCII characters.

### 3.1. The `utf8_to_b64` Code

```javascript
function utf8_to_b64(str) {
	try{return btoa(encodeURIComponent(str).replace(/%([0-9A-F]{2})/g, function(match, p1) {
		return String.fromCharCode(parseInt(p1, 16))
	}));}
	catch(err)
	{return '';}
}
```

### 3.2. Step-by-Step Breakdown

The function takes the single `str` variable as its input and processes it as follows:

1.  **`encodeURIComponent(str)`**: The entire string is first passed through `encodeURIComponent`. This standard JavaScript function escapes all characters that are not basic letters, numbers, or one of `-_.!~*'()`. Crucially, it converts any multi-byte UTF-8 characters (e.g., from a bakery name in another language) into their percent-encoded byte sequences (e.g., the character `Ã©` becomes `%C3%A9`).

2.  **`.replace(/%([0-9A-F]{2})/g, ...)`**: This regular expression finds all percent-encoded byte sequences generated in the previous step.

3.  **`function(match, p1) { return String.fromCharCode(parseInt(p1, 16)) }`**: For each match, this callback function takes the hexadecimal part (the `p1` capture group), converts it to an integer, and then returns the character corresponding to that character code. This effectively transforms the URI-encoded string into a "binary string," where each character represents a single byte of the original UTF-8 data. This is the format that the standard `btoa` function requires.

4.  **`btoa(...)`**: The resulting binary string is finally passed to the standard `btoa` function, which performs the Base64 encoding, producing the final, portable string.

## 4. Finalizing the Export String

After the `str` variable has been successfully encoded, one final piece of data is added.

### 4.1. The `!END!` Terminator

The literal string `!END!` is appended to the end of the Base64-encoded data. 

```javascript
// From the Game.Save function
var str=Game.WriteSave(1);
str+='!END!';
```

This acts as a simple integrity check. When a user imports a save, the game looks for this terminator to verify that the entire save string was likely copied correctly. If it's missing, the save data may be incomplete.

## 5. File Generation: The `saveAs` Utility

With the final, encoded string prepared, the game prompts the user to download it as a file. This is handled by the `saveAs` utility, which is a customized version of the popular FileSaver.js library.

### 5.1. The `saveAs` Code Snippet

```javascript
// From the Game.Save function, which calls saveAs
if (type==0) saveAs(new Blob([str],{type:"text/plain;charset=utf-8"}),Game.bakeryName+'-'+date.getFullYear()+'-'+(date.getMonth()+1)+'-'+date.getDate()+'.txt');
```

### 5.2. Step-by-Step Breakdown

1.  **`new Blob([str],{type:"text/plain;charset=utf-8"})`**: A new `Blob` (Binary Large Object) is created. The `Blob` contains the final, encoded save string (`str`). The MIME type is set to `text/plain` to ensure it's treated as a simple text file.

2.  **`Game.bakeryName + ... + .txt`**: A filename is dynamically generated using the player's bakery name and the current date.

3.  **`saveAs(...)`**: The `saveAs` function takes the `Blob` and the generated filename. Internally, it creates an invisible `<a>` (anchor) element in the HTML, sets the `href` attribute to a URL representing the `Blob`'s data, adds the `download` attribute with the desired filename, and programmatically clicks the link. This action triggers the browser's standard file download prompt, allowing the user to save the `.txt` file to their computer.
