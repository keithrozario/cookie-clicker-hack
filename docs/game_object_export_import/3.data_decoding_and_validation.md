# Cookie Clicker: Data Decoding and Validation

## 1. Introduction

This document details the initial steps of the import process: data decoding and validation. This phase is handled by the `Game.LoadSave` function in `main.js`. Its purpose is to take the raw, user-provided save string, validate its basic integrity, and decode it from Base64 into the plain text serialized string, making it ready for parsing.

## 2. The Entry Point: `Game.LoadSave()`

The entire import process is initiated and managed by the `Game.LoadSave` function. It accepts the raw save string as its primary argument.

```javascript
Game.LoadSave=function(data,ignoreVersionIssues)
{
    //...
```

## 3. Initial Validation: The `!END!` Check

Before any complex decoding occurs, the function performs a simple but crucial validation check. It looks for the `!END!` terminator string that was appended during the export process.

### 3.1. The Code

```javascript
if (data.indexOf('!END!')!=-1)
{
    data=data.substring(0,data.length-5);
}
```

### 3.2. The Process

1.  **`data.indexOf('!END!')`**: The function checks if the `!END!` substring exists within the provided `data` string.
2.  **Conditional Substring**: If the terminator is found, it signifies that the save string is likely complete. The function then removes the `!END!` terminator by taking a substring from the beginning of the string up to 5 characters from the end.
3.  If the terminator is not found, the game proceeds with the import, but the save may be corrupted or incomplete, which will likely cause errors during the later parsing stage.

## 4. Base64 Decoding

After the initial validation, the game decodes the string from Base64. It assumes that if the string does not start with a `{` (the format for an old, unencoded JSON save), it must be a Base64 string.

### 4.1. The `b64_to_utf8` Function

The core of the decoding process is the `b64_to_utf8` function, which is a custom utility designed to safely handle UTF-8 characters.

```javascript
function b64_to_utf8(str) {
	try{return decodeURIComponent(Array.prototype.map.call(atob(str), function(c) {
		return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2)
	}).join(''));}
	catch(err)
	{return '';}
}
```

### 4.2. The Decoding Process in `Game.LoadSave`

The `Game.LoadSave` function wraps the call to `b64_to_utf8` in a `try...catch` block to handle potential errors from a malformed or corrupted Base64 string.

```javascript
var B64=false;
if (data.charAt(0)!='{') B64=true;
if (B64)
{
    try{
        data=b64_to_utf8(data);
    }
    catch(err){
        Game.Notify('Error loading from string','Your save string might be corrupted.',[2,17]);
        console.log('Error loading from string : '+err.message);
        return false;
    }
}
```

### 4.3. Step-by-Step Breakdown of `b64_to_utf8`

The function takes the Base64 `data` string and reverses the encoding process:

1.  **`atob(str)`**: The standard browser function `atob()` is called first. It decodes the Base64 string into a "binary string," where some multi-byte characters may still be incorrectly represented.

2.  **`Array.prototype.map.call(...)`**: This is a trick to iterate over the characters of the binary string as if it were an array.

3.  **`function(c) { return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2) }`**: This callback function is the inverse of the encoding step. For each character `c` in the binary string:
    a.  `c.charCodeAt(0)` gets its character code.
    b.  `.toString(16)` converts that code to its hexadecimal representation.
    c.  `('00' + ...).slice(-2)` pads the hex value with a leading zero if necessary.
    d.  `'%' + ...` prepends the percent sign, creating a URI-encoded byte sequence (e.g., `%C3`).

4.  **`.join('')`**: The array of percent-encoded bytes is joined back into a single string (e.g., `%C3%A9`).

5.  **`decodeURIComponent(...)`**: This final step takes the fully-formed URI-encoded string and correctly decodes it into the original UTF-8 string, properly restoring all special characters.

After these steps, the `data` variable now holds the plain text, serialized game state string, ready to be split by its delimiters and parsed to restore the game state.
